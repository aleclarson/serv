// Generated by CoffeeScript 1.12.4
var assertType, contentTypes, formUrlEncoded, https, isType, qs, readStream, request, responseProto, urlRE;

formUrlEncoded = require("form-urlencoded");

assertType = require("assertType");

isType = require("isType");

https = require("https");

qs = require("querystring");

urlRE = /([^\/]+)(\/.*)?/;

contentTypes = {
  binary: "application/octet-stream",
  form: "application/x-www-form-urlencoded",
  json: "application/json",
  text: "text/plain; charset=utf-8"
};

request = function(url, options) {
  var contentType, data, headers, opts, parts, query;
  assertType(url, String);
  assertType(options, Object);
  if (!url.startsWith("https://")) {
    throw Error("Only HTTPS requests are supported!");
  }
  headers = options.headers || {};
  assertType(headers, Object);
  if (headers["Accept"] == null) {
    headers["Accept"] = "*/*";
  }
  if (query = options.query) {
    if (isType(query, Object)) {
      query = qs.stringify(query);
    }
    if (query) {
      query = "?" + query;
    }
  } else {
    query = "";
  }
  if (data = options.data) {
    contentType = headers["Content-Type"];
    if (options.contentType) {
      assertType(options.contentType, String);
      contentType = contentTypes[options.contentType];
    }
    if (isType(data, Object)) {
      if (contentType === contentTypes.form) {
        data = formUrlEncoded(data);
        contentType += "; charset=utf-8";
      } else {
        data = JSON.stringify(data);
        if (contentType == null) {
          contentType = contentTypes.json;
        }
      }
    } else if (Buffer.isBuffer(data)) {
      if (contentType == null) {
        contentType = contentTypes.binary;
      }
    } else {
      assertType(data, String);
      if (contentType == null) {
        contentType = contentTypes.text;
      }
    }
    headers["Content-Type"] = contentType;
    headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);
  }
  parts = urlRE.exec(url.slice(8));
  opts = {
    host: parts[1],
    path: (parts[2] || "/") + query,
    method: options.method,
    headers: options.headers,
    ca: options.certAuth,
    rejectUnauthorized: options.certAuth != null
  };
  return new Promise(function(resolve, reject) {
    var req;
    req = https.request(opts, function(res) {
      var status;
      status = res.statusCode;
      return readStream(res, function(error, data) {
        if (error) {
          return reject(error);
        } else {
          return resolve({
            __proto__: responseProto,
            success: status >= 200 && status < 300,
            headers: res.headers,
            status: status,
            data: data
          });
        }
      });
    });
    if (data) {
      req.write(data);
    }
    return req.end();
  });
};

module.exports = request;

readStream = function(stream, callback) {
  var chunks;
  chunks = [];
  stream.on("data", function(chunk) {
    return chunks.push(chunk);
  });
  stream.on("end", function() {
    return callback(null, Buffer.concat(chunks));
  });
  return stream.on("error", callback);
};

responseProto = (function() {
  var proto;
  proto = {};
  Object.defineProperty(proto, "json", {
    get: function() {
      return JSON.parse(this.data.toString());
    },
    set: function() {
      throw Error("Cannot set `json`");
    }
  });
  Object.defineProperty(proto, "text", {
    get: function() {
      return this.data.toString();
    },
    set: function() {
      throw Error("Cannot set `text`");
    }
  });
  return proto;
})();
